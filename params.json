{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Beego","tagline":"A web framework for golang,like tornade(python)","body":"## Beego\r\n=======\r\nBeego is an open source version of the scalable, non-blocking web server\r\nand tools that power SNDA's CDN system. Documentation and downloads are\r\navailable at https://github.com/astaxie/beego\r\n\r\nBeego is licensed under the Apache Licence, Version 2.0\r\n(http://www.apache.org/licenses/LICENSE-2.0.html).\r\n\r\n## Installation\r\n============\r\nTo install:\r\n\r\n    go get github.com/astaxie/beego\r\n\r\n## Quick Start\r\n============\r\nHere is the canonical \"Hello, world\" example app for beego:\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/astaxie/beego\"\r\n)\r\n\r\ntype MainController struct {\r\n\tbeego.Controller\r\n}\r\n\r\nfunc (this *MainController) Get() {\r\n\tthis.Ctx.WriteString(\"hello world\")\r\n}\r\n\r\nfunc main() {\r\n\tbeego.RegisterController(\"/\", &MainController{})\r\n\t//beego.HttpPort = 8080 // default\r\n\tbeego.Run()\r\n}\r\n```\r\n\r\n\thttp get http://localhost:8080/\r\n\tHTTP/1.1 200 OK\r\n\tContent-Type: text/plain; charset=utf-8\r\n\tDate: Sat, 15 Dec 2012 16:03:00 GMT\r\n\tTransfer-Encoding: chunked\r\n\t\r\n\thello world\r\n\t\r\nA more complete example use of beego exists here:[beepkg](https://github.com/astaxie/beepkg)\r\n\r\nSome associated tools for beego reside in:[bee](https://github.com/astaxie/bee)\t\t\r\n\t\r\n## Router\r\n============\r\nIn beego, a route is a struct paired with a URL-matching pattern. The struct has many method with the same name of http method to serve the http response. Each route is associated with a block.\r\n```go\r\nbeego.RegisterController(\"/\", &controllers.MainController{})\r\nbeego.RegisterController(\"/admin\", &admin.UserController{})\r\nbeego.RegisterController(\"/admin/index\", &admin.ArticleController{})\r\nbeego.RegisterController(\"/admin/addpkg\", &admin.AddController{})\r\n```\r\nYou can specify custom regular expressions for routes:\r\n```go\r\nbeego.RegisterController(\"/admin/editpkg/:id([0-9]+)\", &admin.EditController{})\r\nbeego.RegisterController(\"/admin/delpkg/:id([0-9]+)\", &admin.DelController{})\r\nbeego.RegisterController(\"/:pkg(.*)\", &controllers.MainController{})\r\n```\t\r\nYou can also create routes for static files:\r\n\r\n\tbeego.BeeApp.SetStaticPath(\"/static\",\"/public\")\r\n\t\r\nThis will serve any files in /static, including files in subdirectories. For example request `/static/logo.gif` or `/static/style/main.css` will server with the file in the path `/pulic/logo.gif` or `/public/style/main.css`\r\n\r\n## Filters / Middleware\r\n============\r\nYou can apply filters to routes, which is useful for enforcing security, redirects, etc.\r\n\r\nYou can, for example, filter all request to enforce some type of security:\r\n```go\r\nvar FilterUser = func(w http.ResponseWriter, r *http.Request) {\r\n    if r.URL.User == nil || r.URL.User.Username() != \"admin\" {\r\n        http.Error(w, \"\", http.StatusUnauthorized)\r\n    }\r\n}\r\n\r\nbeego.Filter(FilterUser)\r\n```\t\r\nYou can also apply filters only when certain REST URL Parameters exist:\r\n```go\r\nbeego.RegisterController(\"/:id([0-9]+)\", &admin.EditController{})\r\nbeego.FilterParam(\"id\", func(rw http.ResponseWriter, r *http.Request) {\r\n    ...\r\n})\r\n```\t\r\nAdditionally, You can apply filters only when certain prefix URL path exist:\r\n```go\r\nbeego.FilterPrefixPath(\"/admin\", func(rw http.ResponseWriter, r *http.Request) {\r\n    … auth \r\n})\r\n```\t\t\r\n\r\n## Controller / Struct\r\n============ \t\r\nTo implement a beego Controller, embed the `beego.Controller` struct:\r\n```go\r\ntype xxxController struct {\r\n\tbeego.Controller\r\n}\r\n```\r\n`beego.Controller` satisfieds the `beego.ControllerInterface` interface, which defines the following methods:\r\n\r\n- Init(ct *Context, cn string)\r\n\r\n\tthis function is init the Context, ChildStruct' name and the Controller's variables.\r\n\t\r\n- Prepare()\r\n\r\n   this function is Run before the HTTP METHOD's Function,as follow defined. In the ChildStruct you can define this function to auth user or init database et.\r\n   \r\n- Get()\r\n\r\n\tWhen the HTTP' Method is GET, the beego router will run this function.Default is HTTP-403. In the ChildStruct you must define the same functon to logical processing.\r\n\t\r\n- Post()\r\n\r\n\tWhen the HTTP' Method is POST, the beego router will run this function.Default is HTTP-403. In the ChildStruct you must define the same functon to logical processing.\r\n\r\n- Delete()\r\n\r\n\tWhen the HTTP' Method is DELETE, the beego router will run this function.Default is HTTP-403. In the ChildStruct you must define the same functon to logical processing.\r\n\r\n- Put()\r\n\r\n\tWhen the HTTP' Method is PUT, the beego router will run this function.Default is HTTP-403. In the ChildStruct you must define the same functon to logical processing.\r\n\r\n- Head()\r\n\r\n\tWhen the HTTP' Method is HEAD, the beego router will run this function.Default is HTTP-403. In the ChildStruct you must define the same functon to logical processing.\r\n\r\n- Patch()\r\n\r\n\tWhen the HTTP' Method is PATCH, the beego router will run this function.Default is HTTP-403. In the ChildStruct you must define the same functon to logical processing.\r\n\r\n- Options()\r\n\r\n\tWhen the HTTP' Method is OPTIONS, the beego router will run this function.Default is HTTP-403. In the ChildStruct you must define the same functon to logical processing.\r\n\r\n- Finish()\r\n\r\n\tthis function is run after the HTTP METHOD's Function,as previous defined. In the ChildStruct you can define this function to close database et.\r\n\r\n- Render() error\r\n\r\n\tthis function is to render the template as user defined. In the strcut you need to call.\r\n\t\r\n\r\nSo you can define ChildStruct method to accomplish the interface's method, now let us see an example:\r\n```go\r\ntype AddController struct {\r\n\tbeego.Controller\r\n}\r\n\r\nfunc (this *AddController) Prepare() {\r\n\r\n}\r\n\r\nfunc (this *AddController) Get() {\r\n\tthis.Layout = \"admin/layout.html\"\r\n\tthis.TplNames = \"admin/add.tpl\"\r\n}\r\n\r\nfunc (this *AddController) Post() {\r\n\t//data deal with\r\n\tthis.Ctx.Request.ParseForm()\r\n\tpkgname := this.Ctx.Request.Form.Get(\"pkgname\")\r\n\tcontent := this.Ctx.Request.Form.Get(\"content\")\r\n\tbeego.Info(this.Ctx.Request.Form)\r\n\tpk := models.GetCruPkg(pkgname)\r\n\tif pk.Id == 0 {\r\n\t\tvar pp models.PkgEntity\r\n\t\tpp.Pid = 0\r\n\t\tpp.Pathname = pkgname\r\n\t\tpp.Intro = pkgname\r\n\t\tmodels.InsertPkg(pp)\r\n\t\tpk = models.GetCruPkg(pkgname)\r\n\t}\r\n\tvar at models.Article\r\n\tat.Pkgid = pk.Id\r\n\tat.Content = content\r\n\tmodels.InsertArticle(at)\r\n\tthis.Ctx.Redirect(302, \"/admin/index\")\r\n}\r\n```\r\n## View / Template\r\n============ \t\t\r\n### template view path\r\n\r\nThe default viewPath is `/views`, you can put the template file in the views. beego will find the template from viewpath.\r\n\r\nalso you can modify the viewpaths like this:\r\n\r\n\tbeego.ViewsPath = \"/myviewpath\"\r\n\t\r\n### template names\r\nbeego will find the template from viewpath. the file is set by user like：\r\n\r\n\tthis.TplNames = \"admin/add.tpl\"\r\n\t\r\nthen beego will find the file in the path:`/views/admin/add.tpl`\r\n\r\nif you don't set TplNames,beego will find like this:\r\n\r\n\tc.TplNames = c.ChildName + \"/\" + c.Ctx.Request.Method + \".\" + c.TplExt\r\n\r\nSo if the ChildName=\"AddController\",Request Method= \"POST\",default TplEXT=\"tpl\"\t\r\nSo beego will file the file in the path:`/view/AddController/POST.tpl`\r\n\r\n### autoRender\r\nIn the controller you needn't to call render function. beego will auto call this function after HTTP Method Call.\r\n\r\nYou can disable automatic invokation of autorender via the AutoRender Flag:\r\n```go\r\nbeego.AutoRender = false\r\n```\r\n\r\n### layout\r\nbeego supports layouts for views. For example:\r\n```go\r\nthis.Layout = \"admin/layout.html\"\r\nthis.TplNames = \"admin/add.tpl\"\t\r\n```\r\n\r\nIn layout.html you must define the variable like this to show sub template's content:\r\n\r\n\t{{.LayoutContent}}\r\n\r\nbeego first parses the TplNames files, renders their content, and appends it to data[\"LayoutContent\"].\r\n\r\n### template function\r\nbeego support users to define template function like this:\r\n```go\r\nfunc hello(in string)(out string){\r\n\tout = in + \"world\"\r\n\treturn\r\n}\r\n\r\nbeego.AddFuncMap(\"hi\",hello)\r\n```\r\n\r\nthen in you template you can use it like this:\r\n\r\n\t{{.Content | hi}}\r\n\t\r\nbeego has three default defined funtion:\r\n\r\n- beegoTplFuncMap[\"markdown\"] = MarkDown\r\n\r\n\tMarkDown parses a string in MarkDown format and returns HTML. Used by the template parser as \"markdown\"\r\n\r\n- beegoTplFuncMap[\"dateformat\"] = DateFormat\r\n\r\n\tDateFormat takes a time and a layout string and returns a string with the formatted date. Used by the template parser as \"dateformat\"\r\n\r\n- beegoTplFuncMap[\"compare\"] = Compare\t\r\n\r\n\tCompare is a quick and dirty comparison function. It will convert whatever you give it to strings and see if the two values are equal.Whitespace is trimmed. Used by the template parser as \"eq\"\r\n\t\r\n### JSON/XML output\r\nYou can use `beego.Controller.ServeJson` or `beego.Controller.ServeXml` for serializing to Json and Xml. I found myself constantly writing code to serialize, set content type, content length, etc. Feel free to use these functions to eliminate redundant code in your app.\r\n\t\t\r\nHelper function for serving Json, sets content type to application/json:\r\n```go\r\nfunc (this *AddController) Get() {\r\n    mystruct := { ... }\r\n    routes.ServeJson(w, &mystruct)\r\n}\r\n```\r\nHelper function for serving Xml, sets content type to application/xml:\r\n```go\r\nfunc (this *AddController) Get() {\r\n    mystruct := { ... }\r\n    routes.ServeXml(w, &mystruct)\r\n}\r\n```\r\n\r\n## Beego Variables\r\n============ \r\nbeego has many default variables, as follow is a list to show:\r\n\r\n- BeeApp       *App\r\n\r\n\tglobal app init by the beego. You needn't to init it, just use it.\r\n\t\r\n- AppName      string\r\n\r\n\tappname is what you project named, default is beego\r\n\r\n- AppPath      string\r\n\r\n\tthis is the project path\r\n\r\n- StaticDir    map[string]string\r\n\r\n\tstaticdir store the map which request url to the static file path\r\n\t\r\n\tdefault is the request url has prefix `static`, then server the path in the app path\r\n\t\r\n- HttpAddr     string\r\n\r\n\thttp listen address, defult is \"\"\r\n\r\n- HttpPort     int\r\n\r\n\thttp listen port, default is 8080\r\n\r\n- RecoverPanic bool\r\n\r\n\tRecoverPanic mean when the program panic  whether the process auto recover,default is true\r\n\r\n- AutoRender   bool\r\n\r\n\twhether run the Render function, default is true\r\n\r\n- ViewsPath    string\r\n\r\n\tthe template path, default is /views\r\n\r\n- RunMode      string //\"dev\" or \"prod\"\r\n\r\n\tthe runmode ,default is prod\r\n\r\n- AppConfig    *Config\r\n\r\n    Appconfig is a result that parse file from conf/app.conf, if this file not exist then the variable is nil. if the file exist, then return the Config as follow.\r\n\r\n## Config\r\n============ \r\n\r\nbeego support parse ini file, beego will parse the default file in the path `conf/app.conf`\r\n\r\nthrow this conf file you can set many Beego Variables to change default values.\r\n\r\napp.conf\r\n\r\n\tappname = beepkg\r\n\thttpaddr = \"127.0.0.1\"\r\n\thttpport = 9090\r\n\trunmode =\"dev\"\r\n\tautorender = false\r\n\tautorecover = false\r\n\tviewspath = \"myview\"\r\n\r\nthis variables will replace the default beego variable's values\r\n\r\nyou can also set you own variables such as database setting\r\n\r\n\tmysqluser = \"root\"\r\n\tmysqlpass = \"rootpass\"\r\n\tmysqlurls = \"127.0.0.1\"\r\n\tmysqldb   = \"beego\"\r\n\t\r\nIn you app you can get the config like this:\r\n\r\n\tbeego.AppConfig.String(\"mysqluser\")\r\n\tbeego.AppConfig.String(\"mysqlpass\")\r\n\tbeego.AppConfig.String(\"mysqlurls\")\r\n\tbeego.AppConfig.String(\"mysqldb\")\r\n\r\n## Logger\r\n============ \t\r\nbeego has a default log named BeeLogger which output to os.Stdout.\r\n\r\nyou can change it output with the standard log.Logger like this:\r\n\r\n\tfd,err := os.OpenFile(\"/opt/app/beepkg/beepkg.log\", os.O_RDWR|os.O_APPEND, 0644)\r\n\tif err != nil {\r\n\t\tbeego.Critical(\"openfile beepkg.log:\", err)\r\n\t\treturn\r\n\t}\r\n\tlg := log.New(fd, \"\", log.Ldate|log.Ltime)\r\n\tbeego.SetLogger(lg)\r\n\t\r\n\r\n### Supported log levels\r\n- Trace - For pervasive information on states of all elementary constructs. Use 'Trace' for in-depth debugging to find problem parts of a function, to check values of temporary variables, etc.\r\n- Debug - For detailed system behavior reports and diagnostic messages to help to locate problems during development.\r\n- Info - For general information on the application's work. Use 'Info' level in your code so that you could leave it 'enabled' even in production. So it is a 'production log level'.\r\n- Warn - For indicating small errors, strange situations, failures that are automatically handled in a safe manner.\r\n- Error - For severe failures that affects application's workflow, not fatal, however (without forcing app shutdown).\r\n- Critical - For producing final messages before application’s death. Note: critical messages force immediate flush because in critical situation it is important to avoid log message losses if app crashes.\r\n- Off - A special log level used to turn off logging\r\n\r\nbeego has follow functions:\r\n\r\n- Trace(v ...interface{})\r\n- Debug(v ...interface{})\r\n- Info(v ...interface{})\r\n- Warn(v ...interface{})\r\n- Error(v ...interface{})\r\n- Critical(v ...interface{})\r\n\r\nyou can set log levels like this :\r\n\r\n\tbeego.SetLevel(beego.LevelError)\r\n\r\nafter set the log levels, in the logs function which below the setlevels willn't output anything\r\n\r\nafter set levels to beego.LevelError\r\n\r\nTrace, Debug, Info, Warn will not output anything. So you can change it when in dev and prod mode."}